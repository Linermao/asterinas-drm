use alloc::sync::Arc;
use core::sync::atomic::{AtomicU64, Ordering};

use hashbrown::HashMap;
use ostd::{mm::PAGE_SIZE, sync::Mutex};

use crate::drm::{
    driver::{DrmDriver, DrmDriverFeatures},
    gem::DrmGemObject,
    mode_config::DrmModeConfig,
};

/// Represents a DRM device instance bound to a specific DRM driver.
///
/// This structure is not directly exposed to userspace; it exists to:
/// - Bind a DRM driver to a concrete device instance
/// - Act as the common anchor point for all associated minors
#[derive(Debug)]
pub struct DrmDevice {
    index: u32,

    driver: Arc<dyn DrmDriver>,
    /// Feature flags and capability bits advertised by the driver for this
    /// device instance.
    ///
    /// These flags describe supported DRM functionality and are used by
    /// userspace (via ioctls) and the DRM core to gate behavior.
    driver_features: DrmDriverFeatures,

    mode_config: Mutex<DrmModeConfig>,

    /// Next fake mmap offset to assign to a GEM object.
    ///
    /// When a GEM object is prepared for userspace memory mapping,
    /// we generate a unique, *fake* offset value that userspace will
    /// later pass to `mmap`. This field holds the next unused offset
    /// to give out. The offset itself has no real address meaning;
    /// it is used solely as a lookup key. Each new mapping request
    /// consumes a new offset from this counter.
    next_offset: AtomicU64,
    offset_table: Mutex<HashMap<u64, Arc<DrmGemObject>>>,
}

impl DrmDevice {
    pub fn new(
        index: u32,
        driver: Arc<dyn DrmDriver>,
        driver_features: DrmDriverFeatures,
        mode_config: DrmModeConfig,
    ) -> Self {
        Self {
            index,
            driver,
            driver_features,
            mode_config: Mutex::new(mode_config),

            // TODO: We currently seed `next_offset` with 0x100000 as a simple starting
            //
            // point for fake mmap offsets. In a complete implementation these offsets
            // would be generated by a dedicated routine (e.g., like `drm_gem_create_mmap_offset()`
            // which allocates and attaches a unique offset per GEM object).
            //
            // For now this arbitrary base value is only used to ensure offsets
            // are nonâ€‘zero and to avoid collisions on simple tests.
            // Proper offset allocation logic should replace this static seed in the future.
            next_offset: AtomicU64::new(0x100000),
            offset_table: Mutex::new(HashMap::new()),
        }
    }

    pub fn index(&self) -> u32 {
        self.index
    }

    pub fn driver(&self) -> Arc<dyn DrmDriver> {
        self.driver.clone()
    }

    pub fn resources(&self) -> &Mutex<DrmModeConfig> {
        &self.mode_config
    }

    pub fn check_feature(&self, features: DrmDriverFeatures) -> bool {
        self.driver_features.contains(features)
    }

    pub fn create_offset(&self, gem_obj: Arc<DrmGemObject>) -> u64 {
        let offset = self
            .next_offset
            .fetch_add(PAGE_SIZE as u64, Ordering::SeqCst);

        self.offset_table.lock().insert(offset, gem_obj);
        offset
    }

    pub fn lookup_offset(&self, offset: &u64) -> Option<Arc<DrmGemObject>> {
        self.offset_table.lock().get(offset).cloned()
    }

    pub fn remove_offset(&self, gem_obj: &Arc<DrmGemObject>) {
        let mut table = self.offset_table.lock();
        table.retain(|_, gem| !Arc::ptr_eq(gem, gem_obj));
    }
}
